// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.8 (swiftlang-5.8.0.124.2 clang-1403.0.22.11.100)
// swift-module-flags: -target arm64-apple-ios13.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name VCL
// swift-module-flags-ignorable: -enable-bare-slash-regex
import Foundation
import Swift
import UIKit
import VCCrypto
@_exported import VCL
import VCToken
import _Concurrency
import _StringProcessing
public struct VCLError : Swift.Error {
  public let payload: Swift.String?
  public let error: Swift.String?
  public let errorCode: Swift.String?
  public let message: Swift.String?
  public let statusCode: Swift.Int?
  public init(payload: Swift.String? = nil, error: Swift.String? = nil, errorCode: Swift.String? = nil, message: Swift.String? = nil, statusCode: Swift.Int? = nil)
  public init(payload: Swift.String)
  public init(error: (any Swift.Error)? = nil, code: Swift.Int? = nil)
  public func toDictionary() -> [Swift.String : Any?]
  public struct CodingKeys {
    public static let KeyPayload: Swift.String
    public static let KeyError: Swift.String
    public static let KeyErrorCode: Swift.String
    public static let KeyMessage: Swift.String
    public static let KeyStatusCode: Swift.String
  }
}
public struct VCLVerifiedProfileDescriptor {
  public let did: Swift.String
  public init(did: Swift.String)
}
public struct VCLCredentialTypeSchema {
  public let payload: [Swift.String : Any]?
  public init(payload: [Swift.String : Any]?)
}
public struct VCLClaims : VCToken.Claims, Swift.Decodable, Swift.Encodable {
  public let all: [Swift.String : Any]
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public init(all: [Swift.String : Any])
  public var iat: Swift.Double? {
    get
  }
  public var exp: Swift.Double? {
    get
  }
  public var nbf: Swift.Double? {
    get
  }
}
public struct VCLFinalizeOffersDescriptor {
  public let credentialManifest: VCLCredentialManifest
  public let approvedOfferIds: [Swift.String]
  public let rejectedOfferIds: [Swift.String]
  public init(credentialManifest: VCLCredentialManifest, approvedOfferIds: [Swift.String], rejectedOfferIds: [Swift.String])
  public func generateRequestBody(jwt: VCLJwt) -> [Swift.String : Any?]
  public struct CodingKeys {
    public static let KeyExchangeId: Swift.String
    public static let KeyApprovedOfferIds: Swift.String
    public static let KeyRejectedOfferIds: Swift.String
    public static let KeyJwt: Swift.String
    public static let KeyProof: Swift.String
    public static let KeyProofType: Swift.String
  }
}
public class VCLCredentialManifestDescriptor {
  final public let uri: Swift.String?
  final public let issuingType: VCLIssuingType
  final public let credentialTypes: [Swift.String]?
  final public let pushDelegate: VCLPushDelegate?
  final public let did: Swift.String?
  final public let vendorOriginContext: Swift.String?
  public init(uri: Swift.String?, issuingType: VCLIssuingType = VCLIssuingType.Career, credentialTypes: [Swift.String]? = nil, pushDelegate: VCLPushDelegate? = nil, vendorOriginContext: Swift.String? = nil)
  public var endpoint: Swift.String? {
    get
  }
  public struct CodingKeys {
    public static let KeyDidPrefix: Swift.String
    public static let KeyCredentialTypes: Swift.String
    public static let KeyPushDelegatePushUrl: Swift.String
    public static let KeyPushDelegatePushToken: Swift.String
    public static let KeyCredentialId: Swift.String
    public static let KeyRefresh: Swift.String
  }
  @objc deinit
}
public struct VCLInitializationDescriptor {
  public let environment: VCLEnvironment
  public let cacheSequence: Swift.Int
  public let keycahinAccessGroupIdentifier: Swift.String?
  public init(environment: VCLEnvironment = VCLEnvironment.PROD, cacheSequence: Swift.Int = 0, keycahinAccessGroupIdentifier: Swift.String? = nil)
}
public class VCLPresentationRequestDescriptor {
  final public let deepLink: VCLDeepLink
  final public let pushDelegate: VCLPushDelegate?
  public init(deepLink: VCLDeepLink, pushDelegate: VCLPushDelegate? = nil)
  public struct CodingKeys {
    public static let KeyId: Swift.String
    public static let KeyPushDelegatePushUrl: Swift.String
    public static let KeyPushDelegatePushToken: Swift.String
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers public class VCLProvider {
  public static func vclInstance() -> any VCL
  @objc deinit
}
public class VCLPresentationSubmission : VCLSubmission {
  public var progressUri: Swift.String
  public init(presentationRequest: VCLPresentationRequest, verifiableCredentials: [VCLVerifiableCredential])
  @objc deinit
}
public struct VCLCredentialTypes {
  public var all: [VCLCredentialType]? {
    get
  }
  public var recommendedTypes: [VCLCredentialType]? {
    get
  }
  public init(all: [VCLCredentialType]?)
}
public struct VCLVerifiableCredential {
  public let inputDescriptor: Swift.String
  public let jwtVc: Swift.String
  public init(inputDescriptor: Swift.String, jwtVc: Swift.String)
}
public enum VCLEnvironment : Swift.String {
  case PROD
  case STAGING
  case QA
  case DEV
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public protocol VCLPlace {
  var payload: [Swift.String : Any] { get }
  var code: Swift.String { get }
  var name: Swift.String { get }
}
public class VCLCredentialManifestDescriptorRefresh : VCLCredentialManifestDescriptor {
  public init(service: VCLService, issuingType: VCLIssuingType = VCLIssuingType.Refresh, credentialIds: [Swift.String])
  override public var endpoint: Swift.String? {
    get
  }
  @objc deinit
}
public struct VCLVerifiedProfile {
  public let payload: [Swift.String : Any]
  public init(payload: [Swift.String : Any])
  public var credentialSubject: [Swift.String : Any]? {
    get
  }
  public var name: Swift.String? {
    get
  }
  public var logo: Swift.String? {
    get
  }
  public var id: Swift.String? {
    get
  }
  public var serviceTypes: VCLServiceTypes {
    get
  }
  public struct CodingKeys {
    public static let KeyCredentialSubject: Swift.String
    public static let KeyName: Swift.String
    public static let KeyLogo: Swift.String
    public static let KeyId: Swift.String
    public static let KeyServiceType: Swift.String
  }
}
public struct VCLExchange {
  public let id: Swift.String?
  public let type: Swift.String?
  public let disclosureComplete: Swift.Bool?
  public let exchangeComplete: Swift.Bool?
  public init(id: Swift.String? = nil, type: Swift.String? = nil, disclosureComplete: Swift.Bool? = nil, exchangeComplete: Swift.Bool? = nil)
  public struct CodingKeys {
    public static let KeyId: Swift.String
    public static let KeyType: Swift.String
    public static let KeyDisclosureComplete: Swift.String
    public static let KeyExchangeComplete: Swift.String
  }
}
extension VCLExchange : Swift.Equatable {
}
public func == (lhs: VCLExchange, rhs: VCLExchange) -> Swift.Bool
public func != (lhs: VCLExchange, rhs: VCLExchange) -> Swift.Bool
public struct VCLCredentialManifest {
  public let jwt: VCLJwt
  public let vendorOriginContext: Swift.String?
  public init(jwt: VCLJwt, vendorOriginContext: Swift.String? = nil)
  public var iss: Swift.String {
    get
  }
  public var did: Swift.String {
    get
  }
  public var issuerId: Swift.String {
    get
  }
  public var exchangeId: Swift.String {
    get
  }
  public var presentationDefinitionId: Swift.String {
    get
  }
  public var finalizeOffersUri: Swift.String {
    get
  }
  public var checkOffersUri: Swift.String {
    get
  }
  public var submitPresentationUri: Swift.String {
    get
  }
  public struct CodingKeys {
    public static let KeyIssuingRequest: Swift.String
    public static let KeyId: Swift.String
    public static let KeyIss: Swift.String
    public static let KeyIssuer: Swift.String
    public static let KeyExchangeId: Swift.String
    public static let KeyPresentationDefinitionId: Swift.String
    public static let KeyMetadata: Swift.String
    public static let KeyCheckOffersUri: Swift.String
    public static let KeyFinalizeOffersUri: Swift.String
    public static let KeySubmitIdentificationUri: Swift.String
  }
}
public struct VCLToken {
  public let value: Swift.String
  public init(value: Swift.String)
}
public func == (lhs: VCLToken, rhs: VCLToken) -> Swift.Bool
public struct VCLCredentialTypeSchemas {
  public var all: [Swift.String : VCLCredentialTypeSchema]? {
    get
  }
  public init(all: [Swift.String : VCLCredentialTypeSchema]?)
}
public func == (lhs: [Any], rhs: [Any]) -> Swift.Bool
public func != (lhs: [Any], rhs: [Any]) -> Swift.Bool
public class VCLSubmission {
  final public let submitUri: Swift.String
  final public let iss: Swift.String
  final public let exchangeId: Swift.String
  final public let presentationDefinitionId: Swift.String
  final public let verifiableCredentials: [VCLVerifiableCredential]?
  final public let pushDelegate: VCLPushDelegate?
  final public let vendorOriginContext: Swift.String?
  final public let jti: Swift.String
  final public let submissionId: Swift.String
  public init(submitUri: Swift.String, iss: Swift.String, exchangeId: Swift.String, presentationDefinitionId: Swift.String, verifiableCredentials: [VCLVerifiableCredential]? = nil, pushDelegate: VCLPushDelegate? = nil, vendorOriginContext: Swift.String? = nil)
  public var payload: [Swift.String : Any] {
    get
  }
  public struct CodingKeys {
    public static let KeyJti: Swift.String
    public static let KeyIss: Swift.String
    public static let KeyId: Swift.String
    public static let KeyVp: Swift.String
    public static let KeyDid: Swift.String
    public static let KeyPushDelegate: Swift.String
    public static let KeyType: Swift.String
    public static let KeyPresentationSubmission: Swift.String
    public static let KeyDefinitionId: Swift.String
    public static let KeyDescriptorMap: Swift.String
    public static let KeyExchangeId: Swift.String
    public static let KeyJwtVp: Swift.String
    public static let KeyPath: Swift.String
    public static let KeyFormat: Swift.String
    public static let KeyVerifiableCredential: Swift.String
    public static let KeyVendorOriginContext: Swift.String
    public static let KeyInputDescriptor: Swift.String
    public static let ValueVerifiablePresentation: Swift.String
    public static let ValueJwtVcFormat: Swift.String
    public static let KeyContext: Swift.String
    public static let ValueContextList: [Swift.String]
  }
  @objc deinit
}
public struct VCLJwt {
  public var header: [Swift.String : Any]? {
    get
  }
  public var payload: [Swift.String : Any]? {
    get
  }
  public var signature: Swift.String? {
    get
  }
  public var encodedJwt: Swift.String {
    get
  }
  public var jwsToken: VCToken.JwsToken<VCLClaims>? {
    get
  }
  public init(header: [Swift.String : Any]?, payload: [Swift.String : Any]?, signature: Swift.String?, encodedJwt: Swift.String)
  public init(encodedJwt: Swift.String)
  public struct CodingKeys {
    public static let KeyTyp: Swift.String
    public static let KeyAlg: Swift.String
    public static let KeyKid: Swift.String
    public static let KeyJwk: Swift.String
    public static let KeyX: Swift.String
    public static let KeyY: Swift.String
    public static let KeyHeader: Swift.String
    public static let KeyPayload: Swift.String
    public static let KeySignature: Swift.String
  }
}
@_hasMissingDesignatedInitializers public class VCLImpl : VCL {
  public func initialize(initializationDescriptor: VCLInitializationDescriptor, successHandler: @escaping () -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  public var countries: VCLCountries? {
    get
  }
  public var credentialTypes: VCLCredentialTypes? {
    get
  }
  public var credentialTypeSchemas: VCLCredentialTypeSchemas? {
    get
  }
  public func getPresentationRequest(presentationRequestDescriptor: VCLPresentationRequestDescriptor, successHandler: @escaping (VCLPresentationRequest) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  public func submitPresentation(presentationSubmission: VCLPresentationSubmission, successHandler: @escaping (VCLSubmissionResult) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  public func getExchangeProgress(exchangeDescriptor: VCLExchangeDescriptor, successHandler: @escaping (VCLExchange) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  public func searchForOrganizations(organizationsSearchDescriptor: VCLOrganizationsSearchDescriptor, successHandler: @escaping (VCLOrganizations) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  public func getCredentialManifest(credentialManifestDescriptor: VCLCredentialManifestDescriptor, successHandler: @escaping (VCLCredentialManifest) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  public func generateOffers(generateOffersDescriptor: VCLGenerateOffersDescriptor, successHandler: @escaping (VCLOffers) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  public func checkForOffers(generateOffersDescriptor: VCLGenerateOffersDescriptor, token: VCLToken, successHandler: @escaping (VCLOffers) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  public func finalizeOffers(finalizeOffersDescriptor: VCLFinalizeOffersDescriptor, token: VCLToken, successHandler: @escaping (VCLJwtVerifiableCredentials) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  public func getCredentialTypesUIFormSchema(credentialTypesUIFormSchemaDescriptor: VCLCredentialTypesUIFormSchemaDescriptor, successHandler: @escaping (VCLCredentialTypesUIFormSchema) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  public func getVerifiedProfile(verifiedProfileDescriptor: VCLVerifiedProfileDescriptor, successHandler: @escaping (VCLVerifiedProfile) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  public func verifyJwt(jwt: VCLJwt, jwkPublic: VCLJwkPublic, successHandler: @escaping (Swift.Bool) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  public func generateSignedJwt(jwtDescriptor: VCLJwtDescriptor, successHandler: @escaping (VCLJwt) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  public func generateDidJwk(successHandler: @escaping (VCLDidJwk) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  @objc deinit
}
public struct VCLExchangeDescriptor {
  public let presentationSubmission: VCLPresentationSubmission
  public let submissionResult: VCLSubmissionResult
  public var processUri: Swift.String {
    get
  }
  public var did: Swift.String {
    get
  }
  public var exchangeId: Swift.String? {
    get
  }
  public var token: VCLToken {
    get
  }
  public init(presentationSubmission: VCLPresentationSubmission, submissionResult: VCLSubmissionResult)
  public struct CodingKeys {
    public static let KeyExchangeId: Swift.String
  }
}
public enum VCLServiceType : Swift.String {
  case Inspector
  case Issuer
  case IdentityIssuer
  case NotaryIssuer
  case CareerIssuer
  case Undefined
  public static func fromString(value: Swift.String) -> VCLServiceType
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct VCLPushDelegate {
  public let pushUrl: Swift.String
  public let pushToken: Swift.String
  public init(pushUrl: Swift.String, pushToken: Swift.String)
  public struct CodingKeys {
    public static let KeyPushUrl: Swift.String
    public static let KeyPushToken: Swift.String
  }
}
public struct VCLRegion : VCLPlace {
  public let payload: [Swift.String : Any]
  public let code: Swift.String
  public let name: Swift.String
  public init(payload: [Swift.String : Any], code: Swift.String, name: Swift.String)
  public enum Codes {
    public static let KeyCode: Swift.String
    public static let KeyName: Swift.String
  }
}
public enum VCLResult<Value> {
  case success(Value)
  case failure(VCLError)
}
public struct VCLCredentialType {
  public let payload: [Swift.String : Any]
  public let id: Swift.String?
  public let schema: Swift.String?
  public let createdAt: Swift.String?
  public let schemaName: Swift.String?
  public let credentialType: Swift.String?
  public let recommended: Swift.Bool?
  public init(payload: [Swift.String : Any], id: Swift.String?, schema: Swift.String? = nil, createdAt: Swift.String? = nil, schemaName: Swift.String? = nil, credentialType: Swift.String? = nil, recommended: Swift.Bool? = nil)
  public struct CodingKeys {
    public static let KeyId: Swift.String
    public static let KeySchema: Swift.String
    public static let KeyCreatedAt: Swift.String
    public static let KeySchemaName: Swift.String
    public static let KeyCredentialType: Swift.String
    public static let KeyRecommended: Swift.String
  }
}
public func == (lhs: VCLCredentialType, rhs: VCLCredentialType) -> Swift.Bool
public func != (lhs: VCLCredentialType, rhs: VCLCredentialType) -> Swift.Bool
public struct VCLDeepLink {
  public let value: Swift.String
  public init(value: Swift.String)
  public var did: Swift.String? {
    get
  }
  public var issuer: Swift.String? {
    get
  }
  public var requestUri: Swift.String? {
    get
  }
  public var vendorOriginContext: Swift.String? {
    get
  }
  public struct CodingKeys {
    public static let KeyDidPrefix: Swift.String
    public static let KeyIssuer: Swift.String
    public static let KeyRequestUri: Swift.String
    public static let KeyVendorOriginContext: Swift.String
  }
}
public struct VCLGenerateOffersDescriptor {
  public let credentialManifest: VCLCredentialManifest
  public let types: [Swift.String]?
  public let offerHashes: [Swift.String]?
  public let identificationVerifiableCredentials: [VCLVerifiableCredential]?
  public init(credentialManifest: VCLCredentialManifest, types: [Swift.String]? = nil, offerHashes: [Swift.String]? = nil, identificationVerifiableCredentials: [VCLVerifiableCredential]? = nil)
  public struct CodingKeys {
    public static let KeyDid: Swift.String
    public static let KeyExchangeId: Swift.String
    public static let KeyTypes: Swift.String
    public static let KeyOfferHashes: Swift.String
  }
}
public struct VCLPresentationRequest {
  public let jwt: VCLJwt
  public let jwkPublic: VCLJwkPublic
  public let deepLink: VCLDeepLink
  public let pushDelegate: VCLPushDelegate?
  public init(jwt: VCLJwt, jwkPublic: VCLJwkPublic, deepLink: VCLDeepLink, pushDelegate: VCLPushDelegate? = nil)
  public var iss: Swift.String {
    get
  }
  public var exchangeId: Swift.String {
    get
  }
  public var presentationDefinitionId: Swift.String {
    get
  }
  public struct CodingKeys {
    public static let KeyId: Swift.String
    public static let KeyIss: Swift.String
    public static let KeyPresentationRequest: Swift.String
    public static let KeyExchangeId: Swift.String
    public static let KeyPresentationDefinition: Swift.String
    public static let KeyMetadata: Swift.String
    public static let KeyProgressUri: Swift.String
    public static let KeySubmitPresentationUri: Swift.String
  }
}
public struct VCLCountries {
  public let all: [VCLCountry]?
  public init(all: [VCLCountry]?)
  public func countryByCode(code: Swift.String) -> VCLCountry?
  public enum Codes {
    public static let BD: Swift.String
    public static let BE: Swift.String
    public static let BF: Swift.String
    public static let BG: Swift.String
    public static let BA: Swift.String
    public static let BB: Swift.String
    public static let WF: Swift.String
    public static let BL: Swift.String
    public static let BM: Swift.String
    public static let BN: Swift.String
    public static let BO: Swift.String
    public static let BH: Swift.String
    public static let BI: Swift.String
    public static let BJ: Swift.String
    public static let BT: Swift.String
    public static let JM: Swift.String
    public static let BV: Swift.String
    public static let BW: Swift.String
    public static let WS: Swift.String
    public static let BQ: Swift.String
    public static let BR: Swift.String
    public static let BS: Swift.String
    public static let JE: Swift.String
    public static let BY: Swift.String
    public static let BZ: Swift.String
    public static let RU: Swift.String
    public static let RW: Swift.String
    public static let RS: Swift.String
    public static let TL: Swift.String
    public static let RE: Swift.String
    public static let TM: Swift.String
    public static let TJ: Swift.String
    public static let RO: Swift.String
    public static let TK: Swift.String
    public static let GW: Swift.String
    public static let GU: Swift.String
    public static let GT: Swift.String
    public static let GS: Swift.String
    public static let GR: Swift.String
    public static let GQ: Swift.String
    public static let GP: Swift.String
    public static let JP: Swift.String
    public static let GY: Swift.String
    public static let GG: Swift.String
    public static let GF: Swift.String
    public static let GE: Swift.String
    public static let GD: Swift.String
    public static let GB: Swift.String
    public static let GA: Swift.String
    public static let SV: Swift.String
    public static let GN: Swift.String
    public static let GM: Swift.String
    public static let GL: Swift.String
    public static let GI: Swift.String
    public static let GH: Swift.String
    public static let OM: Swift.String
    public static let TN: Swift.String
    public static let JO: Swift.String
    public static let HR: Swift.String
    public static let HT: Swift.String
    public static let HU: Swift.String
    public static let HK: Swift.String
    public static let HN: Swift.String
    public static let HM: Swift.String
    public static let VE: Swift.String
    public static let PR: Swift.String
    public static let PS: Swift.String
    public static let PW: Swift.String
    public static let PT: Swift.String
    public static let SJ: Swift.String
    public static let PY: Swift.String
    public static let IQ: Swift.String
    public static let PA: Swift.String
    public static let PF: Swift.String
    public static let PG: Swift.String
    public static let PE: Swift.String
    public static let PK: Swift.String
    public static let PH: Swift.String
    public static let PN: Swift.String
    public static let PL: Swift.String
    public static let PM: Swift.String
    public static let ZM: Swift.String
    public static let EH: Swift.String
    public static let EE: Swift.String
    public static let EG: Swift.String
    public static let ZA: Swift.String
    public static let EC: Swift.String
    public static let IT: Swift.String
    public static let VN: Swift.String
    public static let SB: Swift.String
    public static let ET: Swift.String
    public static let SO: Swift.String
    public static let ZW: Swift.String
    public static let SA: Swift.String
    public static let ES: Swift.String
    public static let ER: Swift.String
    public static let ME: Swift.String
    public static let MD: Swift.String
    public static let MG: Swift.String
    public static let MF: Swift.String
    public static let MA: Swift.String
    public static let MC: Swift.String
    public static let UZ: Swift.String
    public static let MM: Swift.String
    public static let ML: Swift.String
    public static let MO: Swift.String
    public static let MN: Swift.String
    public static let MH: Swift.String
    public static let MK: Swift.String
    public static let MU: Swift.String
    public static let MT: Swift.String
    public static let MW: Swift.String
    public static let MV: Swift.String
    public static let MQ: Swift.String
    public static let MP: Swift.String
    public static let MS: Swift.String
    public static let MR: Swift.String
    public static let IM: Swift.String
    public static let UG: Swift.String
    public static let TZ: Swift.String
    public static let MY: Swift.String
    public static let MX: Swift.String
    public static let IL: Swift.String
    public static let FR: Swift.String
    public static let IO: Swift.String
    public static let SH: Swift.String
    public static let FI: Swift.String
    public static let FJ: Swift.String
    public static let FK: Swift.String
    public static let FM: Swift.String
    public static let FO: Swift.String
    public static let NI: Swift.String
    public static let NL: Swift.String
    public static let NO: Swift.String
    public static let NA: Swift.String
    public static let VU: Swift.String
    public static let NC: Swift.String
    public static let NE: Swift.String
    public static let NF: Swift.String
    public static let NG: Swift.String
    public static let NZ: Swift.String
    public static let NP: Swift.String
    public static let NR: Swift.String
    public static let NU: Swift.String
    public static let CK: Swift.String
    public static let XK: Swift.String
    public static let CI: Swift.String
    public static let CH: Swift.String
    public static let CO: Swift.String
    public static let CN: Swift.String
    public static let CM: Swift.String
    public static let CL: Swift.String
    public static let CC: Swift.String
    public static let CA: Swift.String
    public static let CG: Swift.String
    public static let CF: Swift.String
    public static let CD: Swift.String
    public static let CZ: Swift.String
    public static let CY: Swift.String
    public static let CX: Swift.String
    public static let CR: Swift.String
    public static let CW: Swift.String
    public static let CV: Swift.String
    public static let CU: Swift.String
    public static let SZ: Swift.String
    public static let SY: Swift.String
    public static let SX: Swift.String
    public static let KG: Swift.String
    public static let KE: Swift.String
    public static let SS: Swift.String
    public static let SR: Swift.String
    public static let KI: Swift.String
    public static let KH: Swift.String
    public static let KN: Swift.String
    public static let KM: Swift.String
    public static let ST: Swift.String
    public static let SK: Swift.String
    public static let KR: Swift.String
    public static let SI: Swift.String
    public static let KP: Swift.String
    public static let KW: Swift.String
    public static let SN: Swift.String
    public static let SM: Swift.String
    public static let SL: Swift.String
    public static let SC: Swift.String
    public static let KZ: Swift.String
    public static let KY: Swift.String
    public static let SG: Swift.String
    public static let SE: Swift.String
    public static let SD: Swift.String
    public static let DO: Swift.String
    public static let DM: Swift.String
    public static let DJ: Swift.String
    public static let DK: Swift.String
    public static let VG: Swift.String
    public static let DE: Swift.String
    public static let YE: Swift.String
    public static let DZ: Swift.String
    public static let US: Swift.String
    public static let UY: Swift.String
    public static let YT: Swift.String
    public static let UM: Swift.String
    public static let LB: Swift.String
    public static let LC: Swift.String
    public static let LA: Swift.String
    public static let TV: Swift.String
    public static let TW: Swift.String
    public static let TT: Swift.String
    public static let TR: Swift.String
    public static let LK: Swift.String
    public static let LI: Swift.String
    public static let LV: Swift.String
    public static let TO: Swift.String
    public static let LT: Swift.String
    public static let LU: Swift.String
    public static let LR: Swift.String
    public static let LS: Swift.String
    public static let TH: Swift.String
    public static let TF: Swift.String
    public static let TG: Swift.String
    public static let TD: Swift.String
    public static let TC: Swift.String
    public static let LY: Swift.String
    public static let VA: Swift.String
    public static let VC: Swift.String
    public static let AE: Swift.String
    public static let AD: Swift.String
    public static let AG: Swift.String
    public static let AF: Swift.String
    public static let AI: Swift.String
    public static let VI: Swift.String
    public static let IS: Swift.String
    public static let IR: Swift.String
    public static let AM: Swift.String
    public static let AL: Swift.String
    public static let AO: Swift.String
    public static let AQ: Swift.String
    public static let AS: Swift.String
    public static let AR: Swift.String
    public static let AU: Swift.String
    public static let AT: Swift.String
    public static let AW: Swift.String
    public static let IN: Swift.String
    public static let AX: Swift.String
    public static let AZ: Swift.String
    public static let IE: Swift.String
    public static let ID: Swift.String
    public static let UA: Swift.String
    public static let QA: Swift.String
    public static let MZ: Swift.String
    public static let UK: Swift.String
  }
}
public enum VCLStatusCode : Swift.Int {
  case NetworkError
  case VerificationError
  case Undefined
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public class VCLDidJwk {
  final public let publicKey: VCToken.ECPublicJwk
  final public let privateKey: any VCCrypto.VCCryptoSecret
  public var publicKeyStr: Swift.String {
    get
  }
  public static let DidJwkPrefix: Swift.String
  public init(publicKey: VCToken.ECPublicJwk, privateKey: any VCCrypto.VCCryptoSecret)
  public func generateDidJwkBase64() -> Swift.String
  @objc deinit
}
public protocol VCL {
  func initialize(initializationDescriptor: VCLInitializationDescriptor, successHandler: @escaping () -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  var countries: VCLCountries? { get }
  var credentialTypes: VCLCredentialTypes? { get }
  var credentialTypeSchemas: VCLCredentialTypeSchemas? { get }
  func getPresentationRequest(presentationRequestDescriptor: VCLPresentationRequestDescriptor, successHandler: @escaping (VCLPresentationRequest) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  func submitPresentation(presentationSubmission: VCLPresentationSubmission, successHandler: @escaping (VCLSubmissionResult) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  func getExchangeProgress(exchangeDescriptor: VCLExchangeDescriptor, successHandler: @escaping (VCLExchange) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  func searchForOrganizations(organizationsSearchDescriptor: VCLOrganizationsSearchDescriptor, successHandler: @escaping (VCLOrganizations) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  func getCredentialManifest(credentialManifestDescriptor: VCLCredentialManifestDescriptor, successHandler: @escaping (VCLCredentialManifest) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  func generateOffers(generateOffersDescriptor: VCLGenerateOffersDescriptor, successHandler: @escaping (VCLOffers) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  func checkForOffers(generateOffersDescriptor: VCLGenerateOffersDescriptor, token: VCLToken, successHandler: @escaping (VCLOffers) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  func finalizeOffers(finalizeOffersDescriptor: VCLFinalizeOffersDescriptor, token: VCLToken, successHandler: @escaping (VCLJwtVerifiableCredentials) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  func getCredentialTypesUIFormSchema(credentialTypesUIFormSchemaDescriptor: VCLCredentialTypesUIFormSchemaDescriptor, successHandler: @escaping (VCLCredentialTypesUIFormSchema) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  func getVerifiedProfile(verifiedProfileDescriptor: VCLVerifiedProfileDescriptor, successHandler: @escaping (VCLVerifiedProfile) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  func verifyJwt(jwt: VCLJwt, jwkPublic: VCLJwkPublic, successHandler: @escaping (Swift.Bool) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  func generateSignedJwt(jwtDescriptor: VCLJwtDescriptor, successHandler: @escaping (VCLJwt) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  func generateDidJwk(successHandler: @escaping (VCLDidJwk) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
}
public class VCLCredentialManifestDescriptorByService : VCLCredentialManifestDescriptor {
  public init(service: VCLService, issuingType: VCLIssuingType = VCLIssuingType.Career, credentialTypes: [Swift.String]? = nil, pushDelegate: VCLPushDelegate? = nil)
  override public var endpoint: Swift.String? {
    get
  }
  @objc deinit
}
public class VCLService {
  final public let payload: [Swift.String : Any]
  public init(payload: [Swift.String : Any])
  public var id: Swift.String {
    get
  }
  public var type: Swift.String {
    get
  }
  public var serviceEndpoint: Swift.String {
    get
  }
  @objc deinit
}
public enum VCLIssuingType : Swift.String {
  case Career
  case Identity
  case Refresh
  case Undefined
  public static func fromString(value: Swift.String) -> VCLIssuingType
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public class VCLCredentialManifestDescriptorByDeepLink : VCLCredentialManifestDescriptor {
  public init(deepLink: VCLDeepLink, issuingType: VCLIssuingType = VCLIssuingType.Career)
  @objc deinit
}
public struct VCLOrganization {
  public let payload: [Swift.String : Any]
  public init(payload: [Swift.String : Any])
  public var serviceCredentialAgentIssuers: [VCLServiceCredentialAgentIssuer] {
    get
  }
  public struct CodingKeys {
    public static let KeyService: Swift.String
  }
}
public struct VCLJwtVerifiableCredentials {
  public let all: [VCLJwt]
  public init(all: [VCLJwt])
}
public struct VCLDidJwkDescriptor {
  public let kid: Swift.String
  public init(kid: Swift.String)
}
public class VCLJwtDescriptor {
  final public let didJwk: VCLDidJwk?
  final public let kid: Swift.String
  final public let payload: [Swift.String : Any]
  final public let jti: Swift.String
  final public let iss: Swift.String
  final public let aud: Swift.String?
  public init(didJwk: VCLDidJwk? = nil, kid: Swift.String = UUID().uuidString, payload: [Swift.String : Any], jti: Swift.String = UUID().uuidString, iss: Swift.String, aud: Swift.String? = nil, nonce: Swift.String? = nil)
  @objc deinit
}
public struct VCLJwkPublic {
  public let valueStr: Swift.String
  public let valueDict: [Swift.String : Any]
  public init(valueStr: Swift.String)
  public init(valueDict: [Swift.String : Any])
}
public struct VCLOffers {
  public let payload: [Swift.String : Any]
  public let all: [[Swift.String : Any]]
  public let responseCode: Swift.Int
  public let token: VCLToken
  public let challenge: Swift.String
  public init(payload: [Swift.String : Any], all: [[Swift.String : Any]], responseCode: Swift.Int, token: VCLToken, challenge: Swift.String)
  public struct CodingKeys {
    public static let KeyOffers: Swift.String
    public static let KeyChallenge: Swift.String
  }
}
public struct VCLSubmissionResult {
  public let token: VCLToken
  public let exchange: VCLExchange
  public let jti: Swift.String
  public let submissionId: Swift.String
  public init(token: VCLToken, exchange: VCLExchange, jti: Swift.String, submissionId: Swift.String)
  public struct CodingKeys {
    public static let KeyToken: Swift.String
    public static let KeyExchange: Swift.String
    public static let KeyJti: Swift.String
    public static let KeySubmissionId: Swift.String
  }
}
@_inheritsConvenienceInitializers public class VCLServiceCredentialAgentIssuer : VCLService {
  override public init(payload: [Swift.String : Any])
  public var credentialTypes: [Swift.String]? {
    get
  }
  @objc deinit
}
public struct VCLCountry : VCLPlace {
  public let payload: [Swift.String : Any]
  public let code: Swift.String
  public let name: Swift.String
  public let regions: VCLRegions?
  public init(payload: [Swift.String : Any], code: Swift.String, name: Swift.String, regions: VCLRegions?)
  public enum Codes {
    public static let KeyCode: Swift.String
    public static let KeyName: Swift.String
    public static let KeyRegions: Swift.String
  }
}
public func == (lhs: [Swift.String : Any], rhs: [Swift.String : Any]) -> Swift.Bool
public func != (lhs: [Swift.String : Any], rhs: [Swift.String : Any]) -> Swift.Bool
public class VCLServiceTypes {
  final public let all: [VCLServiceType]
  public init(all: [VCLServiceType])
  convenience public init(serviceType: VCLServiceType)
  convenience public init(issuingType: VCLIssuingType)
  @objc deinit
}
public struct VCLOrganizations {
  public let all: [VCLOrganization]
  public init(all: [VCLOrganization])
  public struct CodingKeys {
    public static let KeyResult: Swift.String
  }
}
public struct VCLCredentialTypesUIFormSchema {
  public let payload: [Swift.String : Any]
  public init(payload: [Swift.String : Any])
  public struct CodingKeys {
    public static let KeyAddressRegion: Swift.String
    public static let KeyAddressCountry: Swift.String
    public static let KeyUiEnum: Swift.String
    public static let KeyUiNames: Swift.String
  }
}
public struct VCLRegions {
  public let all: [VCLRegion]
  public init(all: [VCLRegion])
}
public struct VCLOrganizationsSearchDescriptor {
  public let filter: VCLFilter?
  public let page: VCLPage?
  public let sort: [[Swift.String]]?
  public let query: Swift.String?
  public init(filter: VCLFilter? = nil, page: VCLPage? = nil, sort: [[Swift.String]]? = nil, query: Swift.String? = nil)
  public var queryParams: Swift.String? {
    get
  }
}
public struct VCLFilter {
  public init(did: Swift.String? = nil, serviceTypes: VCLServiceTypes? = nil, credentialTypes: [Swift.String]? = nil)
}
public struct VCLPage {
  public init(size: Swift.String?, skip: Swift.String?)
}
public struct VCLCredentialTypesUIFormSchemaDescriptor {
  public let credentialType: Swift.String
  public let countryCode: Swift.String
  public init(credentialType: Swift.String, countryCode: Swift.String)
}
extension VCLEnvironment : Swift.Equatable {}
extension VCLEnvironment : Swift.Hashable {}
extension VCLEnvironment : Swift.RawRepresentable {}
extension VCLServiceType : Swift.Equatable {}
extension VCLServiceType : Swift.Hashable {}
extension VCLServiceType : Swift.RawRepresentable {}
extension VCLStatusCode : Swift.Equatable {}
extension VCLStatusCode : Swift.Hashable {}
extension VCLStatusCode : Swift.RawRepresentable {}
extension VCLIssuingType : Swift.Equatable {}
extension VCLIssuingType : Swift.Hashable {}
extension VCLIssuingType : Swift.RawRepresentable {}
