// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.1 effective-5.10 (swiftlang-6.1.0.110.21 clang-1700.0.13.3)
// swift-module-flags: -target x86_64-apple-ios13.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-experimental-feature DebugDescriptionMacro -enable-bare-slash-regex -module-name VCL
// swift-module-flags-ignorable: -no-verify-emitted-module-interface -interface-compiler-version 6.1
import Foundation
import Swift
import VCCrypto
@_exported import VCL
import VCToken
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
public struct VCLVerifiedProfileDescriptor {
  public let did: Swift.String
  public init(did: Swift.String)
}
public struct VCLCredentialTypeSchema : Any {
  public let payload: [Swift.String : Any]?
  public init(payload: [Swift.String : Any]?)
}
public struct VCLError : Swift.Error {
  public let payload: Swift.String?
  public let error: Swift.String?
  public let errorCode: Swift.String
  public let requestId: Swift.String?
  public let message: Swift.String?
  public let statusCode: Swift.Int?
  public init(payload: Swift.String? = nil, error: Swift.String? = nil, errorCode: Swift.String = VCLErrorCode.SdkError.rawValue, requestId: Swift.String? = nil, message: Swift.String? = nil, statusCode: Swift.Int? = nil)
  public init(payload: Swift.String?, errorCode: Swift.String? = nil)
  public init(error: (any Swift.Error)? = nil, errorCode: Swift.String = VCLErrorCode.SdkError.rawValue, statusCode: Swift.Int? = nil)
  public func toDictionary() -> [Swift.String : Any?]
  public struct CodingKeys {
    public static let KeyPayload: Swift.String
    public static let KeyError: Swift.String
    public static let KeyErrorCode: Swift.String
    public static let KeyRequestId: Swift.String
    public static let KeyMessage: Swift.String
    public static let KeyStatusCode: Swift.String
  }
}
public struct VCLClaims : VCToken.Claims, Swift.Decodable, Swift.Encodable {
  public let all: [Swift.String : Any]
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public init(all: [Swift.String : Any])
  public var iat: Swift.Double? {
    get
  }
  public var exp: Swift.Double? {
    get
  }
  public var nbf: Swift.Double? {
    get
  }
}
public enum GrantType : Swift.String {
  case AuthorizationCode
  case RefreshToken
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct VCLAuthTokenDescriptor {
  public let authTokenUri: Swift.String
  public let refreshToken: VCLToken?
  public let walletDid: Swift.String?
  public let relyingPartyDid: Swift.String?
  public let vendorOriginContext: Swift.String?
  public init(authTokenUri: Swift.String, refreshToken: VCLToken? = nil, walletDid: Swift.String? = nil, relyingPartyDid: Swift.String? = nil, vendorOriginContext: Swift.String? = nil)
  public init(presentationRequest: VCLPresentationRequest, refreshToken: VCLToken? = nil)
}
public struct VCLFinalizeOffersDescriptor {
  public let credentialManifest: VCLCredentialManifest
  public let challenge: Swift.String?
  public let approvedOfferIds: [Swift.String]
  public let rejectedOfferIds: [Swift.String]
  public init(credentialManifest: VCLCredentialManifest, challenge: Swift.String? = nil, approvedOfferIds: [Swift.String], rejectedOfferIds: [Swift.String])
  public var payload: [Swift.String : Any?] {
    get
  }
  public var aud: Swift.String {
    get
  }
  public var issuerId: Swift.String {
    get
  }
  public var exchangeId: Swift.String {
    get
  }
  public var finalizeOffersUri: Swift.String {
    get
  }
  public var serviceTypes: VCLServiceTypes {
    get
  }
  public var didJwk: VCLDidJwk {
    get
  }
  public var remoteCryptoServicesToken: VCLToken? {
    get
  }
  public struct CodingKeys {
    public static let KeyExchangeId: Swift.String
    public static let KeyApprovedOfferIds: Swift.String
    public static let KeyRejectedOfferIds: Swift.String
    public static let KeyJwt: Swift.String
    public static let KeyProof: Swift.String
    public static let KeyProofType: Swift.String
  }
}
public protocol VCLCredentialManifestDescriptor {
  var uri: Swift.String? { get }
  var issuingType: VCLIssuingType { get }
  var credentialTypes: [Swift.String]? { get }
  var pushDelegate: VCLPushDelegate? { get }
  var did: Swift.String? { get }
  var vendorOriginContext: Swift.String? { get }
  var deepLink: VCLDeepLink? { get }
  var didJwk: VCLDidJwk { get }
  var remoteCryptoServicesToken: VCLToken? { get }
  var endpoint: Swift.String? { get }
  func retrieveEndpoint() -> Swift.String?
  func generateQueryParams() -> Swift.String?
  func toPropsString() -> Swift.String
}
public struct CredentialManifestDescriptorCodingKeys {
  public static let KeyDidPrefix: Swift.String
  public static let KeyCredentialTypes: Swift.String
  public static let KeyPushDelegatePushUrl: Swift.String
  public static let KeyPushDelegatePushToken: Swift.String
  public static let KeyCredentialId: Swift.String
  public static let KeyRefresh: Swift.String
}
extension VCLCredentialManifestDescriptor {
  public func retrieveDid() -> Swift.String?
  public func retrieveEndpoint() -> Swift.String?
  public func generateQueryParams() -> Swift.String?
  public func toPropsString() -> Swift.String
}
public struct VCLPresentationRequestDescriptor {
  public let deepLink: VCLDeepLink
  public let pushDelegate: VCLPushDelegate?
  public let didJwk: VCLDidJwk
  public let remoteCryptoServicesToken: VCLToken?
  public init(deepLink: VCLDeepLink, pushDelegate: VCLPushDelegate? = nil, didJwk: VCLDidJwk, remoteCryptoServicesToken: VCLToken? = nil)
  public struct CodingKeys {
    public static let KeyId: Swift.String
    public static let KeyPushDelegatePushUrl: Swift.String
    public static let KeyPushDelegatePushToken: Swift.String
  }
}
@_hasMissingDesignatedInitializers final public class VCLProvider {
  public static func vclInstance() -> any VCL
  @objc deinit
}
public struct VCLPresentationSubmission : VCLSubmission {
  public let submitUri: Swift.String
  public let exchangeId: Swift.String
  public let presentationDefinitionId: Swift.String
  public let verifiableCredentials: [VCLVerifiableCredential]?
  public let pushDelegate: VCLPushDelegate?
  public let vendorOriginContext: Swift.String?
  public let didJwk: VCLDidJwk
  public let remoteCryptoServicesToken: VCLToken?
  public let jti: Swift.String
  public let submissionId: Swift.String
  public let progressUri: Swift.String
  public init(presentationRequest: VCLPresentationRequest, verifiableCredentials: [VCLVerifiableCredential])
}
public struct VCLCredentialTypes {
  public var all: [VCLCredentialType]? {
    get
  }
  public var recommendedTypes: [VCLCredentialType]? {
    get
  }
  public init(all: [VCLCredentialType]?)
  public func credentialTypeByTypeName(type: Swift.String) -> VCLCredentialType?
}
public protocol VCLKeyService {
  func generateDidJwk(didJwkDescriptor: VCLDidJwkDescriptor, completionBlock: @escaping (VCLResult<VCLDidJwk>) -> Swift.Void)
}
public struct VCLVerifiableCredential {
  public let inputDescriptor: Swift.String
  public let jwtVc: Swift.String
  public init(inputDescriptor: Swift.String, jwtVc: Swift.String)
}
public enum VCLEnvironment : Swift.String {
  case Prod
  case Staging
  case Qa
  case Dev
  public static func fromString(value: Swift.String) -> VCLEnvironment
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public protocol VCLPlace {
  var payload: [Swift.String : Any] { get }
  var code: Swift.String { get }
  var name: Swift.String { get }
}
public struct VCLCredentialManifestDescriptorRefresh : VCLCredentialManifestDescriptor {
  public let uri: Swift.String?
  public let issuingType: VCLIssuingType
  public let credentialTypes: [Swift.String]?
  public let pushDelegate: VCLPushDelegate?
  public var did: Swift.String? {
    get
  }
  public let vendorOriginContext: Swift.String?
  public let deepLink: VCLDeepLink?
  public let didJwk: VCLDidJwk
  public let remoteCryptoServicesToken: VCLToken?
  public var endpoint: Swift.String? {
    get
  }
  public init(service: VCLService, issuingType: VCLIssuingType = VCLIssuingType.Refresh, credentialIds: [Swift.String], didJwk: VCLDidJwk, remoteCryptoServicesToken: VCLToken? = nil)
  public func retrieveEndpoint() -> Swift.String?
  public func generateQueryParams() -> Swift.String?
}
public struct VCLVerifiedProfile {
  public let payload: [Swift.String : Any]
  public init(payload: [Swift.String : Any])
  public var credentialSubject: [Swift.String : Any]? {
    get
  }
  public var name: Swift.String? {
    get
  }
  public var logo: Swift.String? {
    get
  }
  public var id: Swift.String? {
    get
  }
  public var serviceTypes: VCLServiceTypes {
    get
  }
  public struct CodingKeys {
    public static let KeyCredentialSubject: Swift.String
    public static let KeyName: Swift.String
    public static let KeyLogo: Swift.String
    public static let KeyId: Swift.String
    public static let KeyServiceType: Swift.String
  }
}
public struct VCLExchange {
  public let id: Swift.String?
  public let type: Swift.String?
  public let disclosureComplete: Swift.Bool?
  public let exchangeComplete: Swift.Bool?
  public init(id: Swift.String? = nil, type: Swift.String? = nil, disclosureComplete: Swift.Bool? = nil, exchangeComplete: Swift.Bool? = nil)
  public struct CodingKeys {
    public static let KeyId: Swift.String
    public static let KeyType: Swift.String
    public static let KeyDisclosureComplete: Swift.String
    public static let KeyExchangeComplete: Swift.String
  }
}
extension VCLExchange : Swift.Equatable {
}
public func == (lhs: VCLExchange, rhs: VCLExchange) -> Swift.Bool
public func != (lhs: VCLExchange, rhs: VCLExchange) -> Swift.Bool
public struct VCLCredentialManifest {
  public let jwt: VCLJwt
  public let vendorOriginContext: Swift.String?
  public let verifiedProfile: VCLVerifiedProfile
  public let deepLink: VCLDeepLink?
  public let didJwk: VCLDidJwk
  public let remoteCryptoServicesToken: VCLToken?
  public init(jwt: VCLJwt, vendorOriginContext: Swift.String? = nil, verifiedProfile: VCLVerifiedProfile, deepLink: VCLDeepLink? = nil, didJwk: VCLDidJwk, remoteCryptoServicesToken: VCLToken? = nil)
  public var iss: Swift.String {
    get
  }
  public var did: Swift.String {
    get
  }
  public var issuerId: Swift.String {
    get
  }
  public var aud: Swift.String {
    get
  }
  public var exchangeId: Swift.String {
    get
  }
  public var presentationDefinitionId: Swift.String {
    get
  }
  public var finalizeOffersUri: Swift.String {
    get
  }
  public var checkOffersUri: Swift.String {
    get
  }
  public var submitPresentationUri: Swift.String {
    get
  }
  public struct CodingKeys {
    public static let KeyIssuingRequest: Swift.String
    public static let KeyId: Swift.String
    public static let KeyIss: Swift.String
    public static let KeyIssuer: Swift.String
    public static let KeyExchangeId: Swift.String
    public static let KeyPresentationDefinitionId: Swift.String
    public static let KeyMetadata: Swift.String
    public static let KeyCheckOffersUri: Swift.String
    public static let KeyFinalizeOffersUri: Swift.String
    public static let KeySubmitIdentificationUri: Swift.String
  }
}
public struct VCLToken {
  public let value: Swift.String
  public let jwtValue: VCLJwt
  public init(value: Swift.String)
  public init(jwtValue: VCLJwt)
  public var expiresIn: Swift.Double? {
    get
  }
  public struct CodingKeys {
    public static let KeyExp: Swift.String
  }
}
public func == (lhs: VCLToken, rhs: VCLToken) -> Swift.Bool
public struct VCLCredentialTypeSchemas {
  public var all: [Swift.String : VCLCredentialTypeSchema]? {
    get
  }
  public init(all: [Swift.String : VCLCredentialTypeSchema]?)
}
public func == (lhs: [Any], rhs: [Any]) -> Swift.Bool
public func != (lhs: [Any], rhs: [Any]) -> Swift.Bool
public protocol VCLJwtVerifyService {
  func verify(jwt: VCLJwt, publicJwk: VCLPublicJwk, remoteCryptoServicesToken: VCLToken?, completionBlock: @escaping (VCLResult<Swift.Bool>) -> Swift.Void)
}
public protocol VCLSubmission {
  var submitUri: Swift.String { get }
  var exchangeId: Swift.String { get }
  var presentationDefinitionId: Swift.String { get }
  var verifiableCredentials: [VCLVerifiableCredential]? { get }
  var pushDelegate: VCLPushDelegate? { get }
  var vendorOriginContext: Swift.String? { get }
  var didJwk: VCLDidJwk { get }
  var remoteCryptoServicesToken: VCLToken? { get }
  var jti: Swift.String { get }
  var submissionId: Swift.String { get }
}
public struct SubmissionCodingKeys {
  public static let KeyJti: Swift.String
  public static let KeyIss: Swift.String
  public static let KeyId: Swift.String
  public static let KeyVp: Swift.String
  public static let KeyDid: Swift.String
  public static let KeyPushDelegate: Swift.String
  public static let KeyType: Swift.String
  public static let KeyPresentationSubmission: Swift.String
  public static let KeyDefinitionId: Swift.String
  public static let KeyDescriptorMap: Swift.String
  public static let KeyExchangeId: Swift.String
  public static let KeyJwtVp: Swift.String
  public static let KeyPath: Swift.String
  public static let KeyFormat: Swift.String
  public static let KeyVerifiableCredential: Swift.String
  public static let KeyVendorOriginContext: Swift.String
  public static let KeyInputDescriptor: Swift.String
  public static let ValueVerifiablePresentation: Swift.String
  public static let ValueJwtVcFormat: Swift.String
  public static let KeyContext: Swift.String
  public static let ValueContextList: [Swift.String]
}
public struct VCLJwt {
  public var header: [Swift.String : Any]? {
    get
  }
  public var payload: [Swift.String : Any]? {
    get
  }
  public var signature: Swift.String? {
    get
  }
  public var encodedJwt: Swift.String {
    get
  }
  public var jwsToken: VCToken.JwsToken<VCLClaims>? {
    get
  }
  public init(header: [Swift.String : Any]?, payload: [Swift.String : Any]?, signature: Swift.String?, encodedJwt: Swift.String)
  public init(encodedJwt: Swift.String)
  public struct CodingKeys {
    public static let KeyTyp: Swift.String
    public static let KeyAlg: Swift.String
    public static let KeyKid: Swift.String
    public static let KeyJwk: Swift.String
    public static let KeyX: Swift.String
    public static let KeyY: Swift.String
    public static let KeyHeader: Swift.String
    public static let KeyPayload: Swift.String
    public static let KeySignature: Swift.String
    public static let KeyIss: Swift.String
    public static let KeyAud: Swift.String
    public static let KeySub: Swift.String
    public static let KeyJti: Swift.String
    public static let KeyIat: Swift.String
    public static let KeyNbf: Swift.String
    public static let KeyExp: Swift.String
    public static let KeyNonce: Swift.String
  }
}
@_hasMissingDesignatedInitializers final public class VCLImpl : VCL {
  final public func initialize(initializationDescriptor: VCLInitializationDescriptor, successHandler: @escaping () -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  final public var countries: VCLCountries? {
    get
  }
  final public var credentialTypes: VCLCredentialTypes? {
    get
  }
  final public var credentialTypeSchemas: VCLCredentialTypeSchemas? {
    get
  }
  final public func getPresentationRequest(presentationRequestDescriptor: VCLPresentationRequestDescriptor, successHandler: @escaping (VCLPresentationRequest) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  final public func submitPresentation(presentationSubmission: VCLPresentationSubmission, authToken: VCLAuthToken?, successHandler: @escaping (VCLSubmissionResult) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  final public func getExchangeProgress(exchangeDescriptor: VCLExchangeDescriptor, successHandler: @escaping (VCLExchange) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  final public func searchForOrganizations(organizationsSearchDescriptor: VCLOrganizationsSearchDescriptor, successHandler: @escaping (VCLOrganizations) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  final public func getCredentialManifest(credentialManifestDescriptor: any VCLCredentialManifestDescriptor, successHandler: @escaping (VCLCredentialManifest) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  final public func generateOffers(generateOffersDescriptor: VCLGenerateOffersDescriptor, successHandler: @escaping (VCLOffers) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  final public func checkForOffers(generateOffersDescriptor: VCLGenerateOffersDescriptor, sessionToken: VCLToken, successHandler: @escaping (VCLOffers) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  final public func finalizeOffers(finalizeOffersDescriptor: VCLFinalizeOffersDescriptor, sessionToken: VCLToken, successHandler: @escaping (VCLJwtVerifiableCredentials) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  final public func getAuthToken(authTokenDescriptor: VCLAuthTokenDescriptor, successHandler: @escaping (VCLAuthToken) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  final public func getCredentialTypesUIFormSchema(credentialTypesUIFormSchemaDescriptor: VCLCredentialTypesUIFormSchemaDescriptor, successHandler: @escaping (VCLCredentialTypesUIFormSchema) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  final public func getVerifiedProfile(verifiedProfileDescriptor: VCLVerifiedProfileDescriptor, successHandler: @escaping (VCLVerifiedProfile) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  final public func verifyJwt(jwt: VCLJwt, publicJwk: VCLPublicJwk, remoteCryptoServicesToken: VCLToken? = nil, successHandler: @escaping (Swift.Bool) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  final public func generateSignedJwt(jwtDescriptor: VCLJwtDescriptor, didJwk: VCLDidJwk, remoteCryptoServicesToken: VCLToken? = nil, successHandler: @escaping (VCLJwt) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  final public func generateDidJwk(didJwkDescriptor: VCLDidJwkDescriptor = VCLDidJwkDescriptor(), successHandler: @escaping (VCLDidJwk) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  @objc deinit
}
public struct VCLExchangeDescriptor {
  public let presentationSubmission: VCLPresentationSubmission
  public let submissionResult: VCLSubmissionResult
  public var processUri: Swift.String {
    get
  }
  public var exchangeId: Swift.String? {
    get
  }
  public var sessionToken: VCLToken {
    get
  }
  public init(presentationSubmission: VCLPresentationSubmission, submissionResult: VCLSubmissionResult)
  public struct CodingKeys {
    public static let KeyExchangeId: Swift.String
  }
}
public enum VCLServiceType : Swift.String {
  case Inspector
  case Issuer
  case NotaryIssuer
  case CareerIssuer
  case IdentityIssuer
  case IdDocumentIssuer
  case NotaryIdDocumentIssuer
  case ContactIssuer
  case NotaryContactIssuer
  case Undefined
  public static func fromString(value: Swift.String) -> VCLServiceType
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct VCLPushDelegate {
  public let pushUrl: Swift.String
  public let pushToken: Swift.String
  public init(pushUrl: Swift.String, pushToken: Swift.String)
  public struct CodingKeys {
    public static let KeyPushUrl: Swift.String
    public static let KeyPushToken: Swift.String
  }
}
public enum VCLErrorCode : Swift.String {
  case RemoteServicesUrlsNotFount
  case InjectedServicesNotFount
  case CredentialTypeNotRegistered
  case IssuerRequiresIdentityPermission
  case IssuerRequiresNotaryPermission
  case InvalidCredentialSubjectType
  case InvalidCredentialSubjectContext
  case IssuerUnexpectedPermissionFailure
  case MismatchedRequestIssuerDid
  case MismatchedOfferIssuerDid
  case MismatchedCredentialIssuerDid
  case MismatchedPresentationRequestInspectorDid
  case SdkError
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct VCLRegion : VCLPlace {
  public let payload: [Swift.String : Any]
  public let code: Swift.String
  public let name: Swift.String
  public init(payload: [Swift.String : Any], code: Swift.String, name: Swift.String)
  public enum Codes {
    public static let KeyCode: Swift.String
    public static let KeyName: Swift.String
  }
}
public enum VCLResult<Value> {
  case success(Value)
  case failure(VCLError)
}
public struct VCLCredentialType {
  public let payload: [Swift.String : Any]
  public let id: Swift.String?
  public let schema: Swift.String?
  public let createdAt: Swift.String?
  public let schemaName: Swift.String?
  public let credentialType: Swift.String?
  public let recommended: Swift.Bool?
  public let jsonldContext: [Swift.String]?
  public let issuerCategory: Swift.String?
  public init(payload: [Swift.String : Any], id: Swift.String? = nil, schema: Swift.String? = nil, createdAt: Swift.String? = nil, schemaName: Swift.String? = nil, credentialType: Swift.String? = nil, recommended: Swift.Bool? = nil, jsonldContext: [Swift.String]? = nil, issuerCategory: Swift.String? = nil)
  public struct CodingKeys {
    public static let KeyId: Swift.String
    public static let KeySchema: Swift.String
    public static let KeyCreatedAt: Swift.String
    public static let KeySchemaName: Swift.String
    public static let KeyCredentialType: Swift.String
    public static let KeyRecommended: Swift.String
    public static let KeyJsonldContext: Swift.String
    public static let KeyIssuerCategory: Swift.String
  }
}
public func == (lhs: VCLCredentialType, rhs: VCLCredentialType) -> Swift.Bool
public func != (lhs: VCLCredentialType, rhs: VCLCredentialType) -> Swift.Bool
public struct VCLDeepLink {
  public let value: Swift.String
  public init(value: Swift.String)
  public var requestUri: Swift.String? {
    get
  }
  public var vendorOriginContext: Swift.String? {
    get
  }
  public var did: Swift.String? {
    get
  }
  public struct CodingKeys {
    public static let KeyDidPrefix: Swift.String
    public static let KeyRequestUri: Swift.String
    public static let KeyVendorOriginContext: Swift.String
    public static let KeyIssuerDid: Swift.String
    public static let KeyInspectorDid: Swift.String
  }
}
public enum VCLCryptoServiceType : Swift.String {
  case Local
  case Remote
  case Injected
  public static func fromString(value: Swift.String) -> VCLCryptoServiceType
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct VCLGenerateOffersDescriptor {
  public let credentialManifest: VCLCredentialManifest
  public let types: [Swift.String]?
  public let offerHashes: [Swift.String]?
  public let identificationVerifiableCredentials: [VCLVerifiableCredential]?
  public init(credentialManifest: VCLCredentialManifest, types: [Swift.String]? = nil, offerHashes: [Swift.String]? = nil, identificationVerifiableCredentials: [VCLVerifiableCredential]? = nil)
  public var payload: [Swift.String : Any?] {
    get
  }
  public var issuerId: Swift.String {
    get
  }
  public var exchangeId: Swift.String {
    get
  }
  public var checkOffersUri: Swift.String {
    get
  }
  public struct CodingKeys {
    public static let KeyDid: Swift.String
    public static let KeyExchangeId: Swift.String
    public static let KeyTypes: Swift.String
    public static let KeyOfferHashes: Swift.String
  }
}
public struct VCLKeyServiceUrls {
  public let createDidKeyServiceUrl: Swift.String
  public init(createDidKeyServiceUrl: Swift.String)
}
public struct VCLIdentificationSubmission : VCLSubmission {
  public let submitUri: Swift.String
  public let exchangeId: Swift.String
  public let presentationDefinitionId: Swift.String
  public let verifiableCredentials: [VCLVerifiableCredential]?
  public let pushDelegate: VCLPushDelegate?
  public let vendorOriginContext: Swift.String?
  public let didJwk: VCLDidJwk
  public let remoteCryptoServicesToken: VCLToken?
  public let jti: Swift.String
  public let submissionId: Swift.String
  public init(credentialManifest: VCLCredentialManifest, verifiableCredentials: [VCLVerifiableCredential]? = nil)
}
public struct VCLCryptoServicesDescriptor {
  public let cryptoServiceType: VCLCryptoServiceType
  public let injectedCryptoServicesDescriptor: VCLInjectedCryptoServicesDescriptor?
  public let remoteCryptoServicesUrlsDescriptor: VCLRemoteCryptoServicesUrlsDescriptor?
  public init(cryptoServiceType: VCLCryptoServiceType = VCLCryptoServiceType.Local, injectedCryptoServicesDescriptor: VCLInjectedCryptoServicesDescriptor? = nil, remoteCryptoServicesUrlsDescriptor: VCLRemoteCryptoServicesUrlsDescriptor? = nil)
}
public struct VCLInitializationDescriptor {
  public let environment: VCLEnvironment
  public let xVnfProtocolVersion: VCLXVnfProtocolVersion
  public let cacheSequence: Swift.Int
  public let keycahinAccessGroupIdentifier: Swift.String?
  public let isDebugOn: Swift.Bool
  public let cryptoServicesDescriptor: VCLCryptoServicesDescriptor
  public let isDirectIssuerCheckOn: Swift.Bool
  public init(environment: VCLEnvironment = .Prod, xVnfProtocolVersion: VCLXVnfProtocolVersion = .XVnfProtocolVersion1, cacheSequence: Swift.Int = 0, keycahinAccessGroupIdentifier: Swift.String? = nil, isDebugOn: Swift.Bool = false, cryptoServicesDescriptor: VCLCryptoServicesDescriptor = VCLCryptoServicesDescriptor(), isDirectIssuerCheckOn: Swift.Bool = true)
}
public struct VCLPresentationRequest {
  public let jwt: VCLJwt
  public let verifiedProfile: VCLVerifiedProfile
  public let deepLink: VCLDeepLink
  public let pushDelegate: VCLPushDelegate?
  public let didJwk: VCLDidJwk
  public let remoteCryptoServicesToken: VCLToken?
  public let feed: Swift.Bool
  public let vendorOriginContext: Swift.String?
  public init(jwt: VCLJwt, verifiedProfile: VCLVerifiedProfile, deepLink: VCLDeepLink, pushDelegate: VCLPushDelegate? = nil, didJwk: VCLDidJwk, remoteCryptoServicesToken: VCLToken? = nil)
  public var iss: Swift.String {
    get
  }
  public var exchangeId: Swift.String {
    get
  }
  public var presentationDefinitionId: Swift.String {
    get
  }
  public struct CodingKeys {
    public static let KeyId: Swift.String
    public static let KeyIss: Swift.String
    public static let KeyPresentationRequest: Swift.String
    public static let KeyExchangeId: Swift.String
    public static let KeyPresentationDefinition: Swift.String
    public static let KeyMetadata: Swift.String
    public static let KeyProgressUri: Swift.String
    public static let KeySubmitPresentationUri: Swift.String
    public static let KeyFeed: Swift.String
    public static let KeyAuthTokenUri: Swift.String
  }
}
public struct VCLCountries {
  public let all: [VCLCountry]?
  public init(all: [VCLCountry]?)
  public func countryByCode(code: Swift.String) -> VCLCountry?
  public enum Codes {
    public static let BD: Swift.String
    public static let BE: Swift.String
    public static let BF: Swift.String
    public static let BG: Swift.String
    public static let BA: Swift.String
    public static let BB: Swift.String
    public static let WF: Swift.String
    public static let BL: Swift.String
    public static let BM: Swift.String
    public static let BN: Swift.String
    public static let BO: Swift.String
    public static let BH: Swift.String
    public static let BI: Swift.String
    public static let BJ: Swift.String
    public static let BT: Swift.String
    public static let JM: Swift.String
    public static let BV: Swift.String
    public static let BW: Swift.String
    public static let WS: Swift.String
    public static let BQ: Swift.String
    public static let BR: Swift.String
    public static let BS: Swift.String
    public static let JE: Swift.String
    public static let BY: Swift.String
    public static let BZ: Swift.String
    public static let RU: Swift.String
    public static let RW: Swift.String
    public static let RS: Swift.String
    public static let TL: Swift.String
    public static let RE: Swift.String
    public static let TM: Swift.String
    public static let TJ: Swift.String
    public static let RO: Swift.String
    public static let TK: Swift.String
    public static let GW: Swift.String
    public static let GU: Swift.String
    public static let GT: Swift.String
    public static let GS: Swift.String
    public static let GR: Swift.String
    public static let GQ: Swift.String
    public static let GP: Swift.String
    public static let JP: Swift.String
    public static let GY: Swift.String
    public static let GG: Swift.String
    public static let GF: Swift.String
    public static let GE: Swift.String
    public static let GD: Swift.String
    public static let GB: Swift.String
    public static let GA: Swift.String
    public static let SV: Swift.String
    public static let GN: Swift.String
    public static let GM: Swift.String
    public static let GL: Swift.String
    public static let GI: Swift.String
    public static let GH: Swift.String
    public static let OM: Swift.String
    public static let TN: Swift.String
    public static let JO: Swift.String
    public static let HR: Swift.String
    public static let HT: Swift.String
    public static let HU: Swift.String
    public static let HK: Swift.String
    public static let HN: Swift.String
    public static let HM: Swift.String
    public static let VE: Swift.String
    public static let PR: Swift.String
    public static let PS: Swift.String
    public static let PW: Swift.String
    public static let PT: Swift.String
    public static let SJ: Swift.String
    public static let PY: Swift.String
    public static let IQ: Swift.String
    public static let PA: Swift.String
    public static let PF: Swift.String
    public static let PG: Swift.String
    public static let PE: Swift.String
    public static let PK: Swift.String
    public static let PH: Swift.String
    public static let PN: Swift.String
    public static let PL: Swift.String
    public static let PM: Swift.String
    public static let ZM: Swift.String
    public static let EH: Swift.String
    public static let EE: Swift.String
    public static let EG: Swift.String
    public static let ZA: Swift.String
    public static let EC: Swift.String
    public static let IT: Swift.String
    public static let VN: Swift.String
    public static let SB: Swift.String
    public static let ET: Swift.String
    public static let SO: Swift.String
    public static let ZW: Swift.String
    public static let SA: Swift.String
    public static let ES: Swift.String
    public static let ER: Swift.String
    public static let ME: Swift.String
    public static let MD: Swift.String
    public static let MG: Swift.String
    public static let MF: Swift.String
    public static let MA: Swift.String
    public static let MC: Swift.String
    public static let UZ: Swift.String
    public static let MM: Swift.String
    public static let ML: Swift.String
    public static let MO: Swift.String
    public static let MN: Swift.String
    public static let MH: Swift.String
    public static let MK: Swift.String
    public static let MU: Swift.String
    public static let MT: Swift.String
    public static let MW: Swift.String
    public static let MV: Swift.String
    public static let MQ: Swift.String
    public static let MP: Swift.String
    public static let MS: Swift.String
    public static let MR: Swift.String
    public static let IM: Swift.String
    public static let UG: Swift.String
    public static let TZ: Swift.String
    public static let MY: Swift.String
    public static let MX: Swift.String
    public static let IL: Swift.String
    public static let FR: Swift.String
    public static let IO: Swift.String
    public static let SH: Swift.String
    public static let FI: Swift.String
    public static let FJ: Swift.String
    public static let FK: Swift.String
    public static let FM: Swift.String
    public static let FO: Swift.String
    public static let NI: Swift.String
    public static let NL: Swift.String
    public static let NO: Swift.String
    public static let NA: Swift.String
    public static let VU: Swift.String
    public static let NC: Swift.String
    public static let NE: Swift.String
    public static let NF: Swift.String
    public static let NG: Swift.String
    public static let NZ: Swift.String
    public static let NP: Swift.String
    public static let NR: Swift.String
    public static let NU: Swift.String
    public static let CK: Swift.String
    public static let XK: Swift.String
    public static let CI: Swift.String
    public static let CH: Swift.String
    public static let CO: Swift.String
    public static let CN: Swift.String
    public static let CM: Swift.String
    public static let CL: Swift.String
    public static let CC: Swift.String
    public static let CA: Swift.String
    public static let CG: Swift.String
    public static let CF: Swift.String
    public static let CD: Swift.String
    public static let CZ: Swift.String
    public static let CY: Swift.String
    public static let CX: Swift.String
    public static let CR: Swift.String
    public static let CW: Swift.String
    public static let CV: Swift.String
    public static let CU: Swift.String
    public static let SZ: Swift.String
    public static let SY: Swift.String
    public static let SX: Swift.String
    public static let KG: Swift.String
    public static let KE: Swift.String
    public static let SS: Swift.String
    public static let SR: Swift.String
    public static let KI: Swift.String
    public static let KH: Swift.String
    public static let KN: Swift.String
    public static let KM: Swift.String
    public static let ST: Swift.String
    public static let SK: Swift.String
    public static let KR: Swift.String
    public static let SI: Swift.String
    public static let KP: Swift.String
    public static let KW: Swift.String
    public static let SN: Swift.String
    public static let SM: Swift.String
    public static let SL: Swift.String
    public static let SC: Swift.String
    public static let KZ: Swift.String
    public static let KY: Swift.String
    public static let SG: Swift.String
    public static let SE: Swift.String
    public static let SD: Swift.String
    public static let DO: Swift.String
    public static let DM: Swift.String
    public static let DJ: Swift.String
    public static let DK: Swift.String
    public static let VG: Swift.String
    public static let DE: Swift.String
    public static let YE: Swift.String
    public static let DZ: Swift.String
    public static let US: Swift.String
    public static let UY: Swift.String
    public static let YT: Swift.String
    public static let UM: Swift.String
    public static let LB: Swift.String
    public static let LC: Swift.String
    public static let LA: Swift.String
    public static let TV: Swift.String
    public static let TW: Swift.String
    public static let TT: Swift.String
    public static let TR: Swift.String
    public static let LK: Swift.String
    public static let LI: Swift.String
    public static let LV: Swift.String
    public static let TO: Swift.String
    public static let LT: Swift.String
    public static let LU: Swift.String
    public static let LR: Swift.String
    public static let LS: Swift.String
    public static let TH: Swift.String
    public static let TF: Swift.String
    public static let TG: Swift.String
    public static let TD: Swift.String
    public static let TC: Swift.String
    public static let LY: Swift.String
    public static let VA: Swift.String
    public static let VC: Swift.String
    public static let AE: Swift.String
    public static let AD: Swift.String
    public static let AG: Swift.String
    public static let AF: Swift.String
    public static let AI: Swift.String
    public static let VI: Swift.String
    public static let IS: Swift.String
    public static let IR: Swift.String
    public static let AM: Swift.String
    public static let AL: Swift.String
    public static let AO: Swift.String
    public static let AQ: Swift.String
    public static let AS: Swift.String
    public static let AR: Swift.String
    public static let AU: Swift.String
    public static let AT: Swift.String
    public static let AW: Swift.String
    public static let IN: Swift.String
    public static let AX: Swift.String
    public static let AZ: Swift.String
    public static let IE: Swift.String
    public static let ID: Swift.String
    public static let UA: Swift.String
    public static let QA: Swift.String
    public static let MZ: Swift.String
    public static let UK: Swift.String
  }
}
public enum VCLStatusCode : Swift.Int {
  case NetworkError
  case VerificationError
  case Undefined
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public struct VCLAuthToken {
  public let payload: [Swift.String : Any]
  public let authTokenUri: Swift.String?
  public let walletDid: Swift.String?
  public let relyingPartyDid: Swift.String?
  public let accessToken: VCLToken
  public let refreshToken: VCLToken
  public let tokenType: Swift.String
  public init(payload: [Swift.String : Any], authTokenUri: Swift.String? = nil, walletDid: Swift.String? = nil, relyingPartyDid: Swift.String? = nil)
  public enum CodingKeys {
  }
}
public protocol AuthTokenRepository {
  func getAuthToken(authTokenDescriptor: VCLAuthTokenDescriptor, completionBlock: @escaping (VCLResult<VCLAuthToken>) -> Swift.Void)
}
public struct VCLDidJwk {
  public let did: Swift.String
  public let publicJwk: VCLPublicJwk
  public let kid: Swift.String
  public let keyId: Swift.String
  public var curve: Swift.String {
    get
  }
  public static let DidJwkPrefix: Swift.String
  public static let DidJwkSuffix: Swift.String
  public init(did: Swift.String, publicJwk: VCLPublicJwk, kid: Swift.String, keyId: Swift.String)
  public struct CodingKeys {
    public static let KeyDid: Swift.String
    public static let KeyKid: Swift.String
    public static let KeyKeyId: Swift.String
  }
}
public protocol VCL {
  func initialize(initializationDescriptor: VCLInitializationDescriptor, successHandler: @escaping () -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  var countries: VCLCountries? { get }
  var credentialTypes: VCLCredentialTypes? { get }
  var credentialTypeSchemas: VCLCredentialTypeSchemas? { get }
  func getPresentationRequest(presentationRequestDescriptor: VCLPresentationRequestDescriptor, successHandler: @escaping (VCLPresentationRequest) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  func submitPresentation(presentationSubmission: VCLPresentationSubmission, authToken: VCLAuthToken?, successHandler: @escaping (VCLSubmissionResult) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  func getExchangeProgress(exchangeDescriptor: VCLExchangeDescriptor, successHandler: @escaping (VCLExchange) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  func searchForOrganizations(organizationsSearchDescriptor: VCLOrganizationsSearchDescriptor, successHandler: @escaping (VCLOrganizations) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  func getCredentialManifest(credentialManifestDescriptor: any VCLCredentialManifestDescriptor, successHandler: @escaping (VCLCredentialManifest) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  func generateOffers(generateOffersDescriptor: VCLGenerateOffersDescriptor, successHandler: @escaping (VCLOffers) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  func checkForOffers(generateOffersDescriptor: VCLGenerateOffersDescriptor, sessionToken: VCLToken, successHandler: @escaping (VCLOffers) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  func finalizeOffers(finalizeOffersDescriptor: VCLFinalizeOffersDescriptor, sessionToken: VCLToken, successHandler: @escaping (VCLJwtVerifiableCredentials) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  func getAuthToken(authTokenDescriptor: VCLAuthTokenDescriptor, successHandler: @escaping (VCLAuthToken) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  func getCredentialTypesUIFormSchema(credentialTypesUIFormSchemaDescriptor: VCLCredentialTypesUIFormSchemaDescriptor, successHandler: @escaping (VCLCredentialTypesUIFormSchema) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  func getVerifiedProfile(verifiedProfileDescriptor: VCLVerifiedProfileDescriptor, successHandler: @escaping (VCLVerifiedProfile) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  func verifyJwt(jwt: VCLJwt, publicJwk: VCLPublicJwk, remoteCryptoServicesToken: VCLToken?, successHandler: @escaping (Swift.Bool) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  func generateSignedJwt(jwtDescriptor: VCLJwtDescriptor, didJwk: VCLDidJwk, remoteCryptoServicesToken: VCLToken?, successHandler: @escaping (VCLJwt) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  func generateDidJwk(didJwkDescriptor: VCLDidJwkDescriptor, successHandler: @escaping (VCLDidJwk) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
}
extension VCL {
  public func getPresentationRequest(presentationRequestDescriptor: VCLPresentationRequestDescriptor, successHandler: @escaping (VCLPresentationRequest) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  public func submitPresentation(presentationSubmission: VCLPresentationSubmission, authToken: VCLAuthToken? = nil, successHandler: @escaping (VCLSubmissionResult) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  public func getCredentialManifest(credentialManifestDescriptor: any VCLCredentialManifestDescriptor, successHandler: @escaping (VCLCredentialManifest) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  public func generateOffers(generateOffersDescriptor: VCLGenerateOffersDescriptor, successHandler: @escaping (VCLOffers) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  public func finalizeOffers(finalizeOffersDescriptor: VCLFinalizeOffersDescriptor, sessionToken: VCLToken, successHandler: @escaping (VCLJwtVerifiableCredentials) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  public func verifyJwt(jwt: VCLJwt, publicJwk: VCLPublicJwk, remoteCryptoServicesToken: VCLToken? = nil, successHandler: @escaping (Swift.Bool) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  public func generateSignedJwt(didJwk: VCLDidJwk, jwtDescriptor: VCLJwtDescriptor, remoteCryptoServicesToken: VCLToken? = nil, successHandler: @escaping (VCLJwt) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
  public func generateDidJwk(didJwkDescriptor: VCLDidJwkDescriptor = VCLDidJwkDescriptor(), successHandler: @escaping (VCLDidJwk) -> Swift.Void, errorHandler: @escaping (VCLError) -> Swift.Void)
}
public struct VCLCredentialManifestDescriptorByService : VCLCredentialManifestDescriptor {
  public var uri: Swift.String?
  public var issuingType: VCLIssuingType
  public var credentialTypes: [Swift.String]?
  public var pushDelegate: VCLPushDelegate?
  public var did: Swift.String? {
    get
  }
  public var vendorOriginContext: Swift.String?
  public var deepLink: VCLDeepLink?
  public var didJwk: VCLDidJwk
  public var remoteCryptoServicesToken: VCLToken?
  public var endpoint: Swift.String? {
    get
  }
  public init(service: VCLService, issuingType: VCLIssuingType = VCLIssuingType.Career, credentialTypes: [Swift.String]? = nil, pushDelegate: VCLPushDelegate? = nil, didJwk: VCLDidJwk, remoteCryptoServicesToken: VCLToken? = nil)
  public func toPropsString() -> Swift.String
}
public protocol VCLJwtSignService {
  func sign(jwtDescriptor: VCLJwtDescriptor, nonce: Swift.String?, didJwk: VCLDidJwk, remoteCryptoServicesToken: VCLToken?, completionBlock: @escaping (VCLResult<VCLJwt>) -> Swift.Void)
}
public struct VCLRemoteCryptoServicesUrlsDescriptor {
  public let keyServiceUrls: VCLKeyServiceUrls
  public let jwtServiceUrls: VCLJwtServiceUrls
  public init(keyServiceUrls: VCLKeyServiceUrls, jwtServiceUrls: VCLJwtServiceUrls)
}
public struct VCLService {
  public let payload: [Swift.String : Any]
  public var id: Swift.String {
    get
  }
  public var type: Swift.String {
    get
  }
  public var serviceEndpoint: Swift.String {
    get
  }
  public init(payload: [Swift.String : Any])
  public var credentialTypes: [Swift.String]? {
    get
  }
  public func toPropsString() -> Swift.String
  public struct CodingKeys {
    public static let KeyId: Swift.String
    public static let KeyType: Swift.String
    public static let KeyCredentialTypes: Swift.String
    public static let KeyServiceEndpoint: Swift.String
  }
}
public enum VCLIssuingType : Swift.String {
  case Career
  case Identity
  case Refresh
  case Undefined
  public static func fromString(value: Swift.String) -> VCLIssuingType
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct VCLCredentialManifestDescriptorByDeepLink : VCLCredentialManifestDescriptor {
  public let uri: Swift.String?
  public let issuingType: VCLIssuingType
  public let credentialTypes: [Swift.String]?
  public let pushDelegate: VCLPushDelegate?
  public var did: Swift.String? {
    get
  }
  public let vendorOriginContext: Swift.String?
  public let deepLink: VCLDeepLink?
  public let didJwk: VCLDidJwk
  public let remoteCryptoServicesToken: VCLToken?
  public var endpoint: Swift.String? {
    get
  }
  public init(deepLink: VCLDeepLink, issuingType: VCLIssuingType = VCLIssuingType.Career, pushDelegate: VCLPushDelegate? = nil, didJwk: VCLDidJwk, remoteCryptoServicesToken: VCLToken? = nil)
}
public struct VCLOffer {
  public let payload: [Swift.String : Any]
  public init(payload: [Swift.String : Any])
  public var issuerId: Swift.String {
    get
  }
  public var id: Swift.String {
    get
  }
  public struct CodingKeys {
    public static let KeyId: Swift.String
    public static let KeyDid: Swift.String
    public static let KeyIssuer: Swift.String
  }
}
public struct VCLOrganization : Any {
  public let payload: [Swift.String : Any]
  public init(payload: [Swift.String : Any])
  public var serviceCredentialAgentIssuers: [VCLService] {
    get
  }
  public struct CodingKeys {
    public static let KeyService: Swift.String
  }
}
public struct VCLJwtVerifiableCredentials {
  public let passedCredentials: [VCLJwt]
  public let failedCredentials: [VCLJwt]
  public init(passedCredentials: [VCLJwt], failedCredentials: [VCLJwt])
}
public enum VCLSignatureAlgorithm : Swift.String {
  case ES256
  case SECP256k1
  public var jwsAlgorithm: Swift.String {
    get
  }
  public var curve: Swift.String {
    get
  }
  public static func fromString(value: Swift.String) -> VCLSignatureAlgorithm
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct VCLDidJwkDescriptor {
  public let signatureAlgorithm: VCLSignatureAlgorithm
  public let remoteCryptoServicesToken: VCLToken?
  public init(signatureAlgorithm: VCLSignatureAlgorithm = VCLSignatureAlgorithm.ES256, remoteCryptoServicesToken: VCLToken? = nil)
}
public struct VCLInjectedCryptoServicesDescriptor {
  public let keyService: any VCLKeyService
  public let jwtSignService: any VCLJwtSignService
  public let jwtVerifyService: (any VCLJwtVerifyService)?
  public init(keyService: any VCLKeyService, jwtSignService: any VCLJwtSignService, jwtVerifyService: (any VCLJwtVerifyService)? = nil)
}
public struct VCLJwtDescriptor {
  public let payload: [Swift.String : Any]?
  public let jti: Swift.String
  public let iss: Swift.String
  public let aud: Swift.String?
  public init(payload: [Swift.String : Any]? = nil, jti: Swift.String = UUID().uuidString, iss: Swift.String, aud: Swift.String? = nil)
}
public protocol AuthTokenUseCase {
  func getAuthToken(authTokenDescriptor: VCLAuthTokenDescriptor, completionBlock: @escaping (VCLResult<VCLAuthToken>) -> Swift.Void)
}
public struct VCLPublicJwk {
  public let valueStr: Swift.String
  public let valueDict: [Swift.String : Any]
  public init(valueStr: Swift.String)
  public init(valueDict: [Swift.String : Any])
  public var curve: Swift.String {
    get
  }
}
public struct VCLOffers {
  public let payload: [Swift.String : Any]
  public let all: [VCLOffer]
  public let responseCode: Swift.Int
  public let sessionToken: VCLToken
  public let challenge: Swift.String?
  public init(payload: [Swift.String : Any], all: [VCLOffer], responseCode: Swift.Int, sessionToken: VCLToken, challenge: Swift.String? = nil)
  public static func fromPayload(payloadData: Foundation.Data, responseCode: Swift.Int, sessionToken: VCLToken) -> VCLOffers
  public struct CodingKeys {
    public static let KeyOffers: Swift.String
    public static let KeyChallenge: Swift.String
  }
}
public struct VCLSubmissionResult {
  public let sessionToken: VCLToken
  public let exchange: VCLExchange
  public let jti: Swift.String
  public let submissionId: Swift.String
  public init(sessionToken: VCLToken, exchange: VCLExchange, jti: Swift.String, submissionId: Swift.String)
  public struct CodingKeys {
    public static let KeyToken: Swift.String
    public static let KeyExchange: Swift.String
    public static let KeyJti: Swift.String
    public static let KeySubmissionId: Swift.String
  }
}
public enum VCLXVnfProtocolVersion : Swift.String {
  case XVnfProtocolVersion1
  case XVnfProtocolVersion2
  public static func fromString(value: Swift.String) -> VCLXVnfProtocolVersion
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct VCLCountry : VCLPlace {
  public let payload: [Swift.String : Any]
  public let code: Swift.String
  public let name: Swift.String
  public let regions: VCLRegions?
  public init(payload: [Swift.String : Any], code: Swift.String, name: Swift.String, regions: VCLRegions?)
  public enum Codes {
    public static let KeyCode: Swift.String
    public static let KeyName: Swift.String
    public static let KeyRegions: Swift.String
  }
}
public func == (lhs: [Swift.String : Any], rhs: [Swift.String : Any]) -> Swift.Bool
public func != (lhs: [Swift.String : Any], rhs: [Swift.String : Any]) -> Swift.Bool
public struct VCLServiceTypes {
  public let all: [VCLServiceType]
  public init(all: [VCLServiceType])
  public init(serviceType: VCLServiceType)
  public init(issuingType: VCLIssuingType)
}
public struct VCLJwtServiceUrls {
  public let jwtSignServiceUrl: Swift.String
  public let jwtVerifyServiceUrl: Swift.String?
  public init(jwtSignServiceUrl: Swift.String, jwtVerifyServiceUrl: Swift.String? = nil)
}
public struct VCLOrganizations {
  public let all: [VCLOrganization]
  public init(all: [VCLOrganization])
  public struct CodingKeys {
    public static let KeyResult: Swift.String
  }
}
public struct VCLCredentialTypesUIFormSchema {
  public let payload: [Swift.String : Any]
  public init(payload: [Swift.String : Any])
  public struct CodingKeys {
    public static let KeyAddressRegion: Swift.String
    public static let KeyAddressCountry: Swift.String
    public static let KeyUiEnum: Swift.String
    public static let KeyUiNames: Swift.String
  }
}
public struct VCLRegions {
  public let all: [VCLRegion]
  public init(all: [VCLRegion])
}
public struct VCLOrganizationsSearchDescriptor {
  public let filter: VCLFilter?
  public let page: VCLPage?
  public let sort: [[Swift.String]]?
  public let query: Swift.String?
  public init(filter: VCLFilter? = nil, page: VCLPage? = nil, sort: [[Swift.String]]? = nil, query: Swift.String? = nil)
  public var queryParams: Swift.String? {
    get
  }
}
public struct VCLFilter {
  public init(did: Swift.String? = nil, serviceTypes: VCLServiceTypes? = nil, credentialTypes: [Swift.String]? = nil)
}
public struct VCLPage {
  public init(size: Swift.String?, skip: Swift.String?)
}
public struct VCLCredentialTypesUIFormSchemaDescriptor {
  public let credentialType: Swift.String
  public let countryCode: Swift.String
  public init(credentialType: Swift.String, countryCode: Swift.String)
}
extension GrantType : Swift.Equatable {}
extension GrantType : Swift.Hashable {}
extension GrantType : Swift.RawRepresentable {}
extension VCLEnvironment : Swift.Equatable {}
extension VCLEnvironment : Swift.Hashable {}
extension VCLEnvironment : Swift.RawRepresentable {}
extension VCLServiceType : Swift.Equatable {}
extension VCLServiceType : Swift.Hashable {}
extension VCLServiceType : Swift.RawRepresentable {}
extension VCLErrorCode : Swift.Equatable {}
extension VCLErrorCode : Swift.Hashable {}
extension VCLErrorCode : Swift.RawRepresentable {}
extension VCLCryptoServiceType : Swift.Equatable {}
extension VCLCryptoServiceType : Swift.Hashable {}
extension VCLCryptoServiceType : Swift.RawRepresentable {}
extension VCLStatusCode : Swift.Equatable {}
extension VCLStatusCode : Swift.Hashable {}
extension VCLStatusCode : Swift.RawRepresentable {}
extension VCLIssuingType : Swift.Equatable {}
extension VCLIssuingType : Swift.Hashable {}
extension VCLIssuingType : Swift.RawRepresentable {}
extension VCLSignatureAlgorithm : Swift.Equatable {}
extension VCLSignatureAlgorithm : Swift.Hashable {}
extension VCLSignatureAlgorithm : Swift.RawRepresentable {}
extension VCLXVnfProtocolVersion : Swift.Equatable {}
extension VCLXVnfProtocolVersion : Swift.Hashable {}
extension VCLXVnfProtocolVersion : Swift.RawRepresentable {}
